import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/rendering.dart';

class Chart extends StatelessWidget {
  Chart({ Key key, ChartData data }) : _data = data, super(key: key);

  ChartData _data;
  _ChartWrapper wrapper;

  set data(ChartData data) {
    _data = data;
    if (wrapper != null)
    wrapper.data = data;
  }

  get data => _data;

  @override
  Widget build(BuildContext context) {
    wrapper = new _ChartWrapper(data: data);
    return wrapper;
  }
}

class _ChartWrapper extends LeafRenderObjectWidget {
  _ChartWrapper({ Key key, this.data }) :  super(key: key);

  ChartData data;
  _RenderChart _renderChart;

  @override
  _RenderChart createRenderObject(BuildContext context) {
    _renderChart = new _RenderChart(data: data,
        textTheme: Theme.of(context).textTheme);
    return _renderChart;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderChart renderObject) {
    renderObject
      ..textTheme = Theme.of(context).textTheme;
      // ..data = data;
  }
}

class _RenderChart extends RenderConstrainedBox implements SemanticActionHandler {
  _RenderChart({
    ChartData data,
    TextTheme textTheme
  }) : _painter = new ChartPainter(data: data, textTheme: textTheme),
       super(child: null, additionalConstraints: const BoxConstraints.expand()) {
     _tap = new TapGestureRecognizer()
       ..onTapDown = _handleTapDown
       ..onTap = _handleTap
       ..onTapUp = _handleTapUp
       ..onTapCancel = _handleTapCancel;
  }

  final ChartPainter _painter;
  TapGestureRecognizer _tap;

  void _handleTapDown(Point globalPosition) { }

  void _handleTapUp(Point globalPosition) {
    _painter.handleTap(globalPosition);
    markNeedsPaint();
  }

  void _handleTap() {}

  void _handleTapCancel() {}

  @override
  bool hitTestSelf(Point position) => true;

  @override
  void handleEvent(PointerEvent event, BoxHitTestEntry entry) {
    if (event is PointerDownEvent) {
      _tap.addPointer(event);
    }
  }

  TextTheme get textTheme => _painter.textTheme;
  void set textTheme(TextTheme value) {
    assert(value != null);
    if (value == _painter.textTheme)
      return;
    _painter.textTheme = value;
    markNeedsPaint();
  }

  @override
  void handleSemanticTap() => _handleTap();

  @override
  void handleSemanticLongPress() { }

  @override
  void handleSemanticScrollLeft() { }

  @override
  void handleSemanticScrollRight() { }

  @override
  void handleSemanticScrollUp() { }

  @override
  void handleSemanticScrollDown() { }

  @override
  void paint(PaintingContext context, Offset offset) {
    assert(size.width != null);
    assert(size.height != null);


    // AnimationController animation = new AnimationController(
    //   duration: const Duration(milliseconds: 1800)
    // )..forward();
    //
    //
    // animation.addListener(() {
    //   print('animation value = ${animation.value}');
    //
    //   // var rect = new Rect.fromLTWH(50+100*animation.value, 50+100*animation.value, 100.0, 100.0);
    //   var rect = new Rect.fromLTWH(50.0, 50.0, 100.0, 100.0);
    //   Paint paint = new Paint()
    //     ..strokeWidth = 2.0
    //     ..color = const Color(0xFF000000);
    //   context.canvas.drawRect(rect, paint);
    // });

    _painter.paint(context.canvas, offset & size);
    super.paint(context, offset);
  }
}

class ChartPainter {
  ChartPainter({ TextTheme textTheme, this.data }) : _textTheme = textTheme;

  static const List DEFAULT_COLORS = const [
    const Color(0xFF4285F4), const Color(0xFFDB4437), const Color(0xFF0F9D58)];

  int _selectedColumnIndex = -1;
  var _gridlines = 5;
  var _yAxisLabelMargin = 40.0;
  var _margin = 20;
  List<List<Rect>> _series = [];
  ChartData data;
  List _domain;
  List _range;
  bool _initialized = false;

  // If this is set to true we will _layout() the next time we paint()
  bool _needsLayout = true;

  // The last rectangle that we were drawn into. If it changes we will _layout()
  Rect _rect;

  TextTheme _textTheme;
  TextTheme get textTheme => _textTheme;
  void set textTheme(TextTheme value) {
    assert(value != null);
    if (_textTheme == value)
      return;
    _textTheme = value;
    _needsLayout = true;
  }

  /// Computes the layout positions of components in the chart.
  void _layout() {

    // create a scale from all the input, this is going to be a simple scale,
    // this will later be generated by LinearScale ported from charted.
    var allData = [];
    data.rows.forEach((row) => row.forEach((value) => allData.add(value)));

    // Simple nicing for the tick numbers, this is just for the sample and is
    // not final
    var domainMax = allData.fold(allData[0], math.max);
    if (domainMax % _gridlines != 0) {
      domainMax += _gridlines - domainMax % _gridlines;
    }
    _domain = [0, domainMax];
    _range = [_rect.bottom, _rect.top];
    var scale = new SimpleScale(_domain, _range);

    // Also compute the rangeband offsets for all the inputs, this will be
    // later generated by OrdinalScale ported from charted.
    var barGroups = data.rows.length;
    var barGroupPositions = [];
    var rangeBand = _rect.width / (barGroups + 1);
    var barWidth = rangeBand / data.columns.length / 2;
    for (var i = 0; i < barGroups; i ++) {
      barGroupPositions.add((i + 1) * rangeBand);
    }

    // Produce the set of rectangles to be drawn as the bar, this should be
    // later changed to path for we need rounded cornor only on top side.
    _series.clear();
    for (var i = 0; i < data.columns.length; i++) {
      _series.add([]);
      for (var j = 0; j < barGroups; j++) {
        var left = _rect.left + barGroupPositions[j] -
            (barWidth / 2) * data.columns.length + i * barWidth;
        var right = left + barWidth;
        var top = _rect.bottom + scale.scale(data.rows[j][i]);
        var bottom = _rect.bottom - 1;
        var rect = new Rect.fromLTRB(left, top, right, bottom);
        _series[i].add(rect);
      }
    }

    // We don't need to compute layout again unless something changes
    _needsLayout = false;
  }

  // Paints the axes and some horizontal grid lines
  void _paintGrid(Canvas canvas) {
    Paint paint = new Paint()
      ..strokeWidth = 2.0
      ..color = const Color(0xFF000000);
    var gridPaint = new Paint()
      ..strokeWidth = 1.0
      ..color = const Color(0x88CCCCCC);

    // Draw the x and y axis.
    canvas.drawLine(_rect.topLeft, _rect.bottomLeft, paint);
    canvas.drawLine(_rect.bottomLeft, _rect.bottomRight, paint);

    // Draw the _gridlines and their tick values.
    for (var i = 0; i < _gridlines; i++) {
      // Gridlines
      var left = new Point(_rect.left, _rect.top +
          (_rect.bottom - _rect.top) * i / _gridlines);
      var right = new Point(_rect.right, _rect.top +
          (_rect.bottom - _rect.top) * i / _gridlines);
      canvas.drawLine(left, right, gridPaint);

      // Tick values
      TextSpan textSpan = new TextSpan(
        text: (_domain[1] / _gridlines * (_gridlines - i)).toString(),
        style: textTheme.body1);
      TextPainter textPainter = new TextPainter(textSpan)
        ..maxWidth = _yAxisLabelMargin
        ..layout();
      Offset offset = new Point(_rect.left - _yAxisLabelMargin,
          (_rect.top + (_rect.bottom - _rect.top) * i / _gridlines) -
          textPainter.size.height / 2).toOffset();
      textPainter.paint(canvas, offset);
    }
  }

  /// Paints the bars in the chart.
  void _paintChart(Canvas canvas) {
    // Resets selection if the column is selected then removed.
    if (_selectedColumnIndex >= data.columns.length) {
      _selectedColumnIndex = -1;
    }
    for (var i = 0; i < _series.length; i++) {
      var bars = _series[i];
      var paint = new Paint()
        ..strokeWidth = 2.0
        ..color = DEFAULT_COLORS[i];
      if (_selectedColumnIndex != -1 && _selectedColumnIndex != i) {
        paint.color = paint.color.withAlpha(150);
      }
      for (var j = 0; j < bars.length; j++) {
        canvas.drawRect(bars[j], paint);
      }
    }
  }

  /// Computes layout and paints the grid and chart.
  void paint(Canvas canvas, Rect rect) {
    if (rect != _rect)
      _needsLayout = true;

    // Leave some _margin around the contain rect so I can see the chart area
    // in a clearer way.
    _rect = new Rect.fromLTWH(
      rect.left + _margin + _yAxisLabelMargin,
      rect.top + _margin,
      rect.width - 2 * _margin - _yAxisLabelMargin,
      rect.height - 2 * _margin
    );


    // TESTING ANIMATION CODE.
    if (_initialized) {
      // AnimationController animation = new AnimationController(
      //   duration: const Duration(milliseconds: 1800)
      // )..forward();
      //
      //
      // animation.addListener(() {
      //   print('animation value = ${animation.value}');
      //
      //   // var rect = new Rect.fromLTWH(50+100*animation.value, 50+100*animation.value, 100.0, 100.0);
      //   // var rect = new Rect.fromLTWH(50.0, 50.0, 100.0, 100.0);
      //   // Paint paint = new Paint()
      //   //   ..strokeWidth = 2.0
      //   //   ..color = const Color(0xFF000000);
      //   // canvas.drawRect(rect, paint);
      // });
    }

    if (_needsLayout)
      _layout();
    _paintGrid(canvas);
    _paintChart(canvas);
    _initialized = true;
  }

  /// handles user tapping in the chart, if the tap point is inside of a bar,
  /// the series for the bar is selected (causing other seires to be less
  /// opaque).
  void handleTap(Point point) {
    _selectedColumnIndex = -1;
    for (var i = 0; i < _series.length; i++) {
      if(_series[i].any((e) => e.contains(point))) {
        _selectedColumnIndex = i;
      }
    }
    if (_selectedColumnIndex != -1) {
      _needsLayout = true;
    }
  }
}

class ChartData {
  const ChartData({
    this.columns,
    this.rows
  });

  final List<ChartColumnSpec> columns;
  final List<List<double>> rows;
}

/// Meta information for each column in ChartData, trimmed down to only include
/// a label for the sample chart.
class ChartColumnSpec {
  final String label;
  ChartColumnSpec({this.label});
}

/// A simple scale that assumes domain and range contain only two elements and
/// creates a simple bilinear scale for sample chart.
class SimpleScale {
  List<int> domain;
  List<int> range;
  SimpleScale(this.domain, this.range);

  // Simple linear scale.
  double scale(double value) {
    return (value / (domain[1] - domain[0]) * (range[1] - range[0]));
  }

}
